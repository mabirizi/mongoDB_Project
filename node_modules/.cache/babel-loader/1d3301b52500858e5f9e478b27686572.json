{"ast":null,"code":"/** @license React v16.5.1\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n    /**\n     * A scheduling library to allow scheduling work with more granular priority and\n     * control than requestAnimationFrame and requestIdleCallback.\n     * Current TODO items:\n     * X- Pull out the scheduleWork polyfill built into React\n     * X- Initial test coverage\n     * X- Support for multiple callbacks\n     * - Support for two priorities; serial and deferred\n     * - Better test coverage\n     * - Better docblock\n     * - Polish documentation, API\n     */\n    // This is a built-in polyfill for requestIdleCallback. It works by scheduling\n    // a requestAnimationFrame, storing the time for the start of the frame, then\n    // scheduling a postMessage which gets scheduled after paint. Within the\n    // postMessage handler do as much work as possible until time + frame rate.\n    // By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated.\n    // We want to be using a consistent implementation.\n\n    var localDate = Date; // This initialization code may run even on server environments\n    // if a component just imports ReactDOM (e.g. for findDOMNode).\n    // Some environments might not have setTimeout or clearTimeout.\n    // However, we always expect them to be defined on the client.\n    // https://github.com/facebook/react/pull/13088\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined,\n    // but we will error later if they are missing on the client.\n\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    exports.unstable_now = void 0;\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n\n    exports.unstable_scheduleWork = void 0;\n    exports.unstable_cancelScheduledWork = void 0;\n\n    if (!canUseDOM) {\n      var timeoutIds = new Map();\n\n      exports.unstable_scheduleWork = function (callback, options) {\n        // keeping return type consistent\n        var callbackConfig = {\n          scheduledCallback: callback,\n          timeoutTime: 0,\n          next: null,\n          prev: null\n        };\n        var timeoutId = localSetTimeout(function () {\n          callback({\n            timeRemaining: function () {\n              return Infinity;\n            },\n            didTimeout: false\n          });\n        });\n        timeoutIds.set(callback, timeoutId);\n        return callbackConfig;\n      };\n\n      exports.unstable_cancelScheduledWork = function (callbackId) {\n        var callback = callbackId.scheduledCallback;\n        var timeoutId = timeoutIds.get(callback);\n        timeoutIds.delete(callbackId);\n        localClearTimeout(timeoutId);\n      };\n    } else {\n      {\n        if (typeof console !== 'undefined') {\n          if (typeof localRequestAnimationFrame !== 'function') {\n            console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n          }\n\n          if (typeof localCancelAnimationFrame !== 'function') {\n            console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n          }\n        }\n      }\n      var headOfPendingCallbacksLinkedList = null;\n      var tailOfPendingCallbacksLinkedList = null; // We track what the next soonest timeoutTime is, to be able to quickly tell\n      // if none of the scheduled callbacks have timed out.\n\n      var nextSoonestTimeoutTime = -1;\n      var isIdleScheduled = false;\n      var isAnimationFrameScheduled = false; // requestAnimationFrame does not run when the tab is in the background.\n      // if we're backgrounded we prefer for that work to happen so that the page\n      // continues\tto load in the background.\n      // so we also schedule a 'setTimeout' as a fallback.\n\n      var animationFrameTimeout = 100;\n      var rafID = void 0;\n      var timeoutID = void 0;\n\n      var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n        // schedule rAF and also a setTimeout\n        rafID = localRequestAnimationFrame(function (timestamp) {\n          // cancel the setTimeout\n          localClearTimeout(timeoutID);\n          callback(timestamp);\n        });\n        timeoutID = localSetTimeout(function () {\n          // cancel the requestAnimationFrame\n          localCancelAnimationFrame(rafID);\n          callback(exports.unstable_now());\n        }, animationFrameTimeout);\n      };\n\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      var frameDeadlineObject = {\n        didTimeout: false,\n        timeRemaining: function () {\n          var remaining = frameDeadline - exports.unstable_now();\n          return remaining > 0 ? remaining : 0;\n        }\n      };\n      /**\n       * Handles the case where a callback errors:\n       * - don't catch the error, because this changes debugging behavior\n       * - do start a new postMessage callback, to call any remaining callbacks,\n       * - but only if there is an error, so there is not extra overhead.\n       */\n\n      var callUnsafely = function (callbackConfig, arg) {\n        var callback = callbackConfig.scheduledCallback;\n        var finishedCalling = false;\n\n        try {\n          callback(arg);\n          finishedCalling = true;\n        } finally {\n          // always remove it from linked list\n          exports.unstable_cancelScheduledWork(callbackConfig);\n\n          if (!finishedCalling) {\n            // an error must have been thrown\n            isIdleScheduled = true;\n            window.postMessage(messageKey, '*');\n          }\n        }\n      };\n      /**\n       * Checks for timed out callbacks, runs them, and then checks again to see if\n       * any more have timed out.\n       * Keeps doing this until there are none which have currently timed out.\n       */\n\n\n      var callTimedOutCallbacks = function () {\n        if (headOfPendingCallbacksLinkedList === null) {\n          return;\n        }\n\n        var currentTime = exports.unstable_now(); // TODO: this would be more efficient if deferred callbacks are stored in\n        // min heap.\n        // Or in a linked list with links for both timeoutTime order and insertion\n        // order.\n        // For now an easy compromise is the current approach:\n        // Keep a pointer to the soonest timeoutTime, and check that first.\n        // If it has not expired, we can skip traversing the whole list.\n        // If it has expired, then we step through all the callbacks.\n\n        if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n          // We know that none of them have timed out yet.\n          return;\n        } // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n        // after successfully calling any timed out callbacks.\n        // If a timed out callback throws an error, we could get stuck in a state\n        // where the nextSoonestTimeoutTime was set wrong.\n\n\n        var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n\n        var timedOutCallbacks = []; // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n\n        var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n\n        while (currentCallbackConfig !== null) {\n          var _timeoutTime = currentCallbackConfig.timeoutTime;\n\n          if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n            // it has timed out!\n            timedOutCallbacks.push(currentCallbackConfig);\n          } else {\n            if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n              updatedNextSoonestTimeoutTime = _timeoutTime;\n            }\n          }\n\n          currentCallbackConfig = currentCallbackConfig.next;\n        }\n\n        if (timedOutCallbacks.length > 0) {\n          frameDeadlineObject.didTimeout = true;\n\n          for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n            callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n          }\n        } // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n        // after successfully calling any timed out callbacks.\n\n\n        nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n      }; // We use the postMessage trick to defer idle work until after the repaint.\n\n\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n\n        isIdleScheduled = false;\n\n        if (headOfPendingCallbacksLinkedList === null) {\n          return;\n        } // First call anything which has timed out, until we have caught up.\n\n\n        callTimedOutCallbacks();\n        var currentTime = exports.unstable_now(); // Next, as long as we have idle time, try calling more callbacks.\n\n        while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n          var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n          frameDeadlineObject.didTimeout = false; // callUnsafely will remove it from the head of the linked list\n\n          callUnsafely(latestCallbackConfig, frameDeadlineObject);\n          currentTime = exports.unstable_now();\n        }\n\n        if (headOfPendingCallbacksLinkedList !== null) {\n          if (!isAnimationFrameScheduled) {\n            // Schedule another animation callback so we retry later.\n            isAnimationFrameScheduled = true;\n            scheduleAnimationFrameWithFallbackSupport(animationTick);\n          }\n        }\n      }; // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n\n\n      window.addEventListener('message', idleTick, false);\n\n      var animationTick = function (rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n\n      exports.unstable_scheduleWork = function (callback, options)\n      /* CallbackConfigType */\n      {\n        var timeoutTime = -1;\n\n        if (options != null && typeof options.timeout === 'number') {\n          timeoutTime = exports.unstable_now() + options.timeout;\n        }\n\n        if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n          nextSoonestTimeoutTime = timeoutTime;\n        }\n\n        var scheduledCallbackConfig = {\n          scheduledCallback: callback,\n          timeoutTime: timeoutTime,\n          prev: null,\n          next: null\n        };\n\n        if (headOfPendingCallbacksLinkedList === null) {\n          // Make this callback the head and tail of our list\n          headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n          tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n        } else {\n          // Add latest callback as the new tail of the list\n          scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList; // renaming for clarity\n\n          var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n\n          if (oldTailOfPendingCallbacksLinkedList !== null) {\n            oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n          }\n\n          tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n        }\n\n        if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          scheduleAnimationFrameWithFallbackSupport(animationTick);\n        }\n\n        return scheduledCallbackConfig;\n      };\n\n      exports.unstable_cancelScheduledWork = function (callbackConfig\n      /* CallbackConfigType */\n      ) {\n        if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n          // this callbackConfig has already been cancelled.\n          // cancelScheduledWork should be idempotent, a no-op after first call.\n          return;\n        }\n        /**\n         * There are four possible cases:\n         * - Head/nodeToRemove/Tail -> null\n         *   In this case we set Head and Tail to null.\n         * - Head -> ... middle nodes... -> Tail/nodeToRemove\n         *   In this case we point the middle.next to null and put middle as the new\n         *   Tail.\n         * - Head/nodeToRemove -> ...middle nodes... -> Tail\n         *   In this case we point the middle.prev at null and move the Head to\n         *   middle.\n         * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n         *   In this case we point the Head.next to the Tail and the Tail.prev to\n         *   the Head.\n         */\n\n\n        var next = callbackConfig.next;\n        var prev = callbackConfig.prev;\n        callbackConfig.next = null;\n        callbackConfig.prev = null;\n\n        if (next !== null) {\n          // we have a next\n          if (prev !== null) {\n            // we have a prev\n            // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n            prev.next = next;\n            next.prev = prev;\n            return;\n          } else {\n            // there is a next but not a previous one;\n            // callbackConfig is the head of a list of 2 or more other nodes.\n            next.prev = null;\n            headOfPendingCallbacksLinkedList = next;\n            return;\n          }\n        } else {\n          // there is no next callback config; this must the tail of the list\n          if (prev !== null) {\n            // we have a prev\n            // callbackConfig is the tail of a list of 2 or more other nodes.\n            prev.next = null;\n            tailOfPendingCallbacksLinkedList = prev;\n            return;\n          } else {\n            // there is no previous callback config;\n            // callbackConfig is the only thing in the linked list,\n            // so both head and tail point to it.\n            headOfPendingCallbacksLinkedList = null;\n            tailOfPendingCallbacksLinkedList = null;\n            return;\n          }\n        }\n      };\n    }\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}